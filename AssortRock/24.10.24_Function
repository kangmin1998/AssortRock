========================= std::functional ====================================

1. 함수 포인터를 받을 수 있는 클래스
2. 객체화 시켜서 사용한다.

std::function<int()> Function = std::bind(&Monster::Damage, & newMonster, 10);
-> 함수의 인자는 무조건 8바이트 EX) char [8] = new char[8];

Funtion(); 
-> 인자를 미리 넣고 호출하는 순간!

내가 널어주려는 함수에 인자 갯수에 맞춰서 인자를 매칭시켜서 펑셔널을 만드는 함수.

 - 지연호출
인자를 10이라고 정하고 그 때 호출을 하지 않아도 되는 것을 볼 수 있다.


============================ Delegate ====================================

- 간단히 말하면 함수를 여러개 사용한다는 뜻이다.

void Test(int Value)
{
}
int main()
{
EngineDelegate delegate = Test + Test + Test -> 이런 느낌이다.
}


============================= 전역함수 ================================
std::bind는 생략되고 명시적으로 사용할 수 있다.

?
?
?
?
?
?

=============================== API ===================================

_startfunction <- 새로 추가됨 확인바람.


============== 오브젝트 구조(unreal식으로 구조를 만든다.) ================
 1. Level이라는 클래스를 만들고,
 2. Level을 만들면서 GameMode라는 것을 넣어야 하는 구조를 만들어야 한다.
	ㄴ 여기서 level은 장면을 뜻한다. (화면이 전환되는지 확인.)
		ㄴ 어떤 화면이 나왔다가 다른 화면으로 전환.
		ㄴ 전환 전 -> 전환 후
	- 엔진코어 -> createLevel();
		ㄴ 타일 -> 플레이 -> 엔딩
		ㄴ EX) 엔진코어 -> createLevel<TitleGameMode>();
			   엔진코어 -> createLevel<PlayGameMode>();
			   엔진코어 -> createLevel<EndingGameMode>();
	Actor -> 레벨에서 등장하는 요소 전체.

	Ex)
	class TitleGameMode : pubilc AGameMode
	{
		BeingPlay()
		{
			GetWorld() -> SpawnActor<Player>();
			GetWorld() -> SpawnActor<UI>();
		}

		Tick();
	
	}

	Level은 World의 구성이 어떻게 되어야한다 <- 중첩 로딩.

	World에 level를 집어 넣어서 한장면을 넣어준다?
		ㄴ 몬스터, 맵을 제작하면 한번에 컨텐츠가 엄청 많으므로
		ㄴ level을 따로 나눠서 world에 각각 집어 넣어서
		ㄴ world라는 곳에 level1(map), level2(monster)를 중첩 로딩한다.


================ 언리얼에서 붙이는 네이밍 앞에 A, U ===================
언리얼에서는 모든 오브젝트는 U를 붙입니다.
UObject라는 클래스가 있고 그걸 상속 받는다.
AActor가 있으면
AActor : public UObject <- 라는 문법이 보이게된다.




================ Enginecore -> Object -> Level ===================

 - Ulevel 구성 <- 내가 한번 짜보자.

 레벨 구성

	시작		-

	스테이지	-

	엔딩		-




========================== 네이밍 ====================================
	멤버변수의 이름은 맨앞은 대문자



========================= CreateGameMode =========================================
1. gamemode가 먼저 만들어진다.
2. pawn이 만들어진다.

========================= winapi의 기본랜더링 =========================================
winapi의 기본랜더링의 핵심은 HDC이다.
HDC는 window창에 그리기 위한 권한 핸들입니다.
윈도우 한개는 main HDC만 존재할 수 있다. -> backbuffer

윈도우와 연결된 HDC만 사용해야한다.
윈도우에서 무언가 그리려는 함수의 대부분의 첫번째 인자는 HDC이다.

=========================Dynamiccast =========================================

다이나믹 캐스트는 부모자식 관계일때 호출하는 캐스트입니다.
-> 그 관계를 확인할 때 호출하는 캐스트

vptr 기반으로 동작
ㄴ 부모 -> 자식
ㄴ 자식 -> 부모
-> 양쪽다 쓸 수 있지만 업캐스팅일때는 암시적으로 형변환이 잘되고 안전하기 때문이다.
굳이 명시적으로





virtual(다형클래스)